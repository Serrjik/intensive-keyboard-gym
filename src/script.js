// Средняя длина англоязычного слова.
const AVERAGE_LENGTH_OF_AN_ENGLISH_WORD = 5
// Средняя длина русскоязычного слова.
const AVERAGE_LENGTH_OF_AN_RUSSIAN_WORD = 7.2

// Поле для ввода символов.
const input = document.querySelector('input')
// Клавиши с символами на экранной клавиатуре.
const letters = Array.from(document.querySelectorAll('[data-letters]'))
// Специальные клавиши на экранной клавиатуре.
const specs = Array.from(document.querySelectorAll('[data-spec]'))
// Блок со строками, которые нужно отобразить и напечатать.
const textExample = document.querySelector('#textExample')
// Индикатор количества набранных символов в минуту.
const symbolsPerMinute = document.querySelector('#symbolsPerMinute')
// Индикатор "Слов в минуту:".
const wordsPerMinuteIndicator = document.querySelector('#wordsPerMinute')
// Индикатор "Реальных слов в минуту:".
const realWordsPerMinuteIndicator =
	document.querySelector('#realWordsPerMinuteIndicator')
// Индикатор количества ошибок.
const errorPercent = document.querySelector('#errorPercent')

// const text = `В начале XIII в. в Центральной Азии возникло новое государство - Монгольская империя. Объединение монгольских племен в немалой степени было вызвано изменением климатических условий местности, где проживали монголы. XI и XII вв. были благоприятными для монголов. Длительный период влажных лет в восточной степи привел к тому, что умножились стада, а, следовательно, одна и та же территория могла прокормить больше людей. Произошло увеличение населения в Монголии. Однако в конце XII в. климат стал постепенно меняться в сторону ухудшения, стал более засушливым. Кочевое скотоводство стало малопродуктивным, в степи стало много избыточного населения. Началась обычная в таких условиях борьба с соседями за пастбища, а также вторжения на земли соседей-земледельцев.
// Чингисхан.Огромную роль в создании Монгольской империи сыграл Темуджин. Железная воля, властолюбие и целеустремленность позволили Темуджину собрать монголов в единое политическое целое и спаять общество на основе т. н. закона Чингисхана - Яссы. На съезде монгольской знати (курултае) в 1206 г. создатель империи Темуджин (Темучин) был провозглашен великим ханом всех монголов и принял имя Чингисхан. Монгольская империя оказалось исключительно боеспособной и жизнеспособной. Чингисхан силой объединил под своей рукой всех монголов, некоторые соседние племена и на основе родового признака создал войско, которому в XII - XIII вв., в среднеазиатских государствах, на Руси и в Европе равных не было. В последующие годы монгольские отряды подчинили себе окрестные народы, беспощадно уничтожая всех непокорных. В середине 20-х гг. XIII в. в состав монгольского государства вошли Северный Китай, Средняя Азия, Северная Индия.
// Рядовой единицей монгольского войска была десятка - семья, ближайшие родственники одной юрты, одного аила. Потом следовала сотня, в нее входили люди одного рода. Тысяча могла объединять два или три аила, далее шла тьма - десятитысячный отряд. В войске Чингисхана действовала Ясса: если в бою кто-то из десятки побежит от врага, то казнили всю десятку; если в сотне побежит десятка, то казнили всю сотню, если побежит сотня и откроет брешь врагу, то казнили всю тысячу. Основную ударную силу монголов составляла конница. Каждый воин имел два-три лука, веревочный аркан, топор, хорошо владел саблей. Лошадь воина покрывалась шкурами для защиты. Голову, шею и грудь воина защищали железный или медный шлем, панцирь из кожи. Монгольская конница на своих низкорослых выносливых конях могла проходить в сутки до 80 км, а с обозами, стенобитными, огнеметными орудиями - до 10 км.
// К 1211 г. монголы завоевали землю бурят, якутов, киргизов и уйгуров, т.е. подчинили себе практически все основные племена и народы Сибири, обложив их данью. В 1211 г. Чингисхан приступил к завоеванию северного Китая, которое было завершено лишь к 1234 г. Монголы в процессе завоевания заимствовали у китайцев различную военную технику, а также научились осаждать крепости при помощи стенобитных и осадных машин. Китайцы передали монголам и важную науку дипломатии. Монголы одними из первых стали придерживаться принципа неприкосновенности послов, беспощадно карая народы за нарушение этого принципа. Схватка грузин с монголо-татарами.
// В 1218 г. татаро-монголы покорили всю Корею. После этого Чингисхан устремил свой взгляд на богатейшие государства Средней Азии. Цель Чингисхана - покорение городов Бухары, Самарканда, Мерва, Ургенча и других. Всё завоевание было совершено за 3 года - 1219-1221 гг. Хорезмшах Мухаммед недооценил силу Чингисхана, вследствие чего вынужден был спастись бегством. В погоню было отправлено несколько туменов под руководством военноначальников Джебе и Субэдея. Монголы огнем и мечом прошли по Северному Ирану, вышли на Кавказ, разрушили несколько древних и богатых городов, разбили грузинские войска, проникли через Ширванское ущелье на Северный Кавказ и столкнулись с половцами. В это время состоялась первая встреча русских воинов с новым врагом и произошла (1223 г.). К концу жизни Чингисхана (1227г.) монголы подчинили огромные территории от Тихого океана на востоке до Каспийского моря на западе.
// Причины успехов монголов состояли в следующем: Первая причина - Китай, Средняя Азия и Иран переживали в то время период феодальной раздробленности и не смогли организовать коллективного отпора монголам. Вторая причина - это великолепная военная и политическая подготовка вторжения. Проведя разведку, монголы стравливали народы и раздували междоусобицы. Если удавалось, то монголы занимали ключевые военные посты в армии намеченной жертвы (Хорезм). Тактика завоеваний была отточена до совершенства. По возможности избегая фронтальных сражений, кочевники разбивали противника по частям, предварительно измотав его непрерывными стычками и налетами.
// Еще при жизни Чингисхан разделил огромную империю между сыновьями на улусы, которые были в составе единого государства еще 40 лет после его смерти (1227 г.). Улус Угедэя - собственно Монголия и Северный Китай, улус Чагатая - Средняя Азия, улус Джучи - пространства к западу и югу от Иртыша до Уральских гор, Аральского и Каспийского морей. В 40-х гг. XIII в. выделился еще один улус, охватывающий часть Ирана и Закавказье, который был отдан внуку Чингисхана Хулагу. Далее процесс распада великой империи ускорился. В начале XIV в. улус Джучи распался на Синюю и Белую Орду. Впоследствии за Белой Ордой, располагавшейся в бассейне рек Волги и Дона, в Крыму и на Северном Кавказе, закрепилось название Золотой Орды.`

getText = async () => {
	const response = await fetch('./src/texts.txt')

	if (response.ok) {
		return await response.text()

	}

	else {
		return ''
	}
}

main = async () => {
	const text = await getText()

	// Партия тренировки.
	const party = createParty(text)

	init()

	function init () {
		// Повесить обработчик нажатия клавиши на поле для ввода символов.
		input.addEventListener('keydown', keydownHandler)

		// Повесить обработчик отжатия клавиши на поле для ввода символов.
		input.addEventListener('keyup', keyupHandler)

		// Обновить визуальную часть приложения.
		viewUpdate()
	}

	// Обработчик нажатия клавиши.
	function keydownHandler (event) {
		event.preventDefault()

		// Клавиша на экранной клавиатуре, соответствующая прожатой.
		const letter = letters.find(x => x.dataset.letters.includes(event.key))

		// Если на экранной клавиатуре есть клавиша, соответствующая прожатой:
		if (letter) {
			// Подсветить прожатую клавишу.
			letter.classList.add('pressed')
			// Обработать символ, соответствующий отжатой клавише.
			press(event.key)
			return
		}

		// Ключ нажатой клавиши в нижнем регистре.
		let key = event.key.toLowerCase()

		// Если нажали на пробел:
		if (key === ' ') {
			key = 'space'
			// Обработать пробел.
			press(' ')
		}

		// Если нажали Ввод:
		if (key === 'enter') {
			// Обработать спецсимвол "Ввод".
			press('\n')
		}

		// Специальные клавиши на экранной клавиатуре, соответствующие прожатой.
		const ownSpecs = specs.filter(x => x.dataset.spec === key)

		/*
			Если на экранной клавиатуре есть хотя бы 1 специальная клавиша,
			соответствующая прожатой:
		*/
		if (ownSpecs.length) {
			// Подсветить все специальные клавиши, соответствующие прожатой.
			ownSpecs.forEach(spec => spec.classList.add('pressed'))
			return
		}

		// Если была прожата клавиша НЕ с символом и НЕ специальная клавиша:
		console.warn('Неизвестный вид клавиши.', event)
	}

	// Обработчик отжатия клавиши.
	function keyupHandler (event) {
		event.preventDefault()

		// Клавиша на экранной клавиатуре, соответствующая отжатой.
		const letter = letters.find(x => x.dataset.letters.includes(event.key))

		// Если на экранной клавиатуре есть клавиша, соответствующая отжатой:
		if (letter) {
			// Убрать подсветку с отжатой клавиши.
			letter.classList.remove('pressed')
			return
		}

		// Ключ отжатой клавиши в нижнем регистре.
		let key = event.key.toLowerCase()

		// Если отжали пробел:
		if (key === ' ') {
			key = 'space'
		}

		// Специальные клавиши на экранной клавиатуре, соответствующие отжатой.
		const ownSpecs = specs.filter(x => x.dataset.spec === key)

		/*
			Если на экранной клавиатуре есть хотя бы 1 специальная клавиша,
			соответствующая отжатой:
		*/
		if (ownSpecs.length) {
			// Убрать подсветку со всех специальных клавиш, соответствующих отжатой.
			ownSpecs.forEach(spec => spec.classList.remove('pressed'))
			return
		}
	}

	// Функция создаёт и возвращает партию тренировки. Принимает текст.
	function createParty (text) {
		// Партия тренировки.
		const party = {
			// Текст для тренировки.
			text,
			// Строки, которые нужно отобразить и напечатать.
			strings: [],
			// Максимально допустимая длина строки.
			maxStringLength: 70,
			// Максимальное количество отображаемых под полем ввода строк.
			maxShowStrings: 3,
			// Индекс строки, которую нужно отобразить сейчас.
			currentStringIndex: 0,
			// Индекс символа в текущей строке, которую нужно напечатать сейчас.
			currentPressedIndex: 0,
			// Массив символов, в которых ошиблись.
			errors: [],
			// Флаг - началась ли партия тренировки?
			started: false,

			// Флаг - начили ли набор строки? Если true, счётчики активны.
			statisticFlag: false,
			// Время полного набора всего текста (всех строк).
			timerCounter: 0,
			// Момент начала набора текущей строки.
			startTimer: 0,
			// Количество символов в минуту.
			// letterPerMinute: 0,
			// Процент ошибок.
			// errorPercent: 0,
			// Количество ошибок в текущей строке.
			errorCounter: 0,
			// Количество напечатанных символов в текущей строке
			commonCounter: 0,
		}

		/*
			Заменим в тексте все переносы строки на переносы строки и пробел, чтобы
			слова, разделенные переносом строки, тоже считались двумя разными
			словами.
		*/
		party.text = party.text.replace(/\r\n/g, '\n ')
		// Разобьём текст на слова по разделителю "пробел".
		const words = party.text.split(' ')

		// Строка для отображения.
		let string = []
		// Пройти по всем словам текста.
		for (const word of words) {
			// Формируем строку из слов.
			/*
				Длина строки, которую можно создать после добавления текущего слова
				с учётом наличия или отсутствия пробела после последнего слова
				(если есть символ переноса строки).
			*/
			const newStringLength =
				[...string, word].join(' ').length + !word.includes('\n')

			/*
				Если длина строки, которую можно создать после добавления текущего
				слова оказывается больше чем максимально допустимая длина строки
				или добавленное слово включает в себя перенос строки:
			*/
			if (newStringLength > party.maxStringLength) {
				/*
					Добавить строку в массив строк, которые нужно отобразить и
					напечатать, добавив пробел в конце.
				*/
				party.strings.push(string.join(' ') + ' ')
				string = []
			}

			// Добавить текущее слово в следующую строку.
			string.push(word)

			// Если слово содержит перенос строки:
			if (word.includes('\n')) {
				/*
					Добавить строку в массив строк, которые нужно отобразить и
					напечатать, не добавляя пробела в конце.
				*/
				party.strings.push(string.join(' '))
				string = []
			}
		}

		/*
			Если после прохода по всем словам строка НЕ пустая:
		*/
		if (string.length) {
			/*
				Добавить строку в массив строк,
				которые нужно отобразить и напечатать.
			*/
			party.strings.push(string.join(' '))
		}

		return party
	}

	// Функция принимает и обрабатывает набранный символ.
	function press (letter) {
		/*
			После ввода первого символа в поле ввода
			поднять флаг начала партии тренировки!
		*/
		party.started = true

		// Если флаг "Происходит ли печать" опущен:
		if (!party.statisticFlag) {
			// Поднять флаг "Происходит ли печать"!
			party.statisticFlag = true
			// Запомнить момент начала набора текущей строки.
			party.startTimer = Date.now()
		}

		/*
			Соответствует ли символ, который пытаются напечатать, символу,
			который нужно напечатать?
		*/
		// Строка, которую нужно набрать в данный момент.
		const string = party.strings[party.currentStringIndex]

		// Символ, который нужно напечатать.
		const mustLetter = string[party.currentPressedIndex]

		// Если эти символы совпадают:
		if (letter === mustLetter) {
			// Указать следующий символ в текущей строке, который нужно напечатать.
			party.currentPressedIndex++

			// Если индекс следующего символа превышает длину текущей строки:
			if (string.length <= party.currentPressedIndex) {
				/*
					Установить индекс следующего символа в следующей строке,
					который нужно напечатать.
				*/
				party.currentPressedIndex = 0
				/*
					Увеличить индекс строки, которую нужно отобразить сейчас
					(взять следующую строку).
				*/
				party.currentStringIndex++

				/*
					Опустить флаг "Происходит ли печать",
					чтобы можно было делать передышки между строками.
				*/
				party.statisticFlag = false

				// Запомнить время полного набора текущей строки.
				party.timerCounter = Date.now() - party.startTimer
			}
		}

		/*
			Если эти символы НЕ совпадают и символ, который попытались напечатать,
			ещё НЕ входит в массив символов, в которых ошиблись:
			*/
			else if (!party.errors.includes(mustLetter)) {
				// Объявить символ, который попытались напечатать, ошибочным.
				party.errors.push(mustLetter)
				// Увеличить счётчик количества ошибок в текущем тексте.
				party.errorCounter++
			}

			// Увеличить счётчик напечатанных символов в текущей строке тренировки.
			party.commonCounter++

		// Обновить визуальную часть приложения.
		viewUpdate()
	}

	/*
		Функция обновляет визуальную часть приложения. Вставляет отображаемые под
		полем ввода строки, которые нужно набрать.
	*/
	function viewUpdate () {
		// Отобразить под полем ввода строки, которые нужно отобразить и напечатать.

		// Строка, которую нужно набрать в данный момент.
		const string = party.strings[party.currentStringIndex]

		// TODO - здесь изменить или удалить код.
		// Если строки для ввода закончились:
		if (!string) {
			console.log('Текст текущей партии набран!')
			return
		}
		
		// Количество слов в строке, которую нужно набрать в данный момент.
		const wordsPerLine = string.trim().split(' ').length

		// Строки, которые нужно отобразить и напечатать.
		const showedStrings = party.strings.slice(
			party.currentStringIndex,
			party.currentStringIndex + party.maxShowStrings
		)

		// Контейнер для строк, которые нужно отобразить и напечатать.
		const div = document.createElement('div')

		// Первая строка из тех, которые нужно отобразить и напечатать.
		const firstLine = document.createElement('div')
		firstLine.classList.add('line')
		div.append(firstLine)

		// Часть текста, который уже успели напечатать.
		const done = document.createElement('span')
		done.classList.add('done')
		done.textContent = string.slice(0, party.currentPressedIndex)
		/*
			Добавить в первую строку часть текста, который уже успели напечатать
			и оставшуюся часть строки (которую нужно напечатать).
		*/
		firstLine.append(
			done,
			...string
				.slice(party.currentPressedIndex)
				.split('')
				.map(letter => {
					// Если текущий символ - пробел:
					if (letter === ' ') {
						// Заменить пробел на отображаемый символ пробела.
						return '␣'
					}

					// Если текущий символ - конец строки:
					if (letter === '\n') {
						/*
							Заменить конец строки на отображаемый символ конца
							параграфа.
						*/
						return '¶'
					}

					// Если ранее ошиблись в наборе символа:
					if (party.errors.includes(letter)) {
						// Вернём этот символ выделенным.
						const errorSpan = document.createElement('span')
						// Выделить этот символ.
						errorSpan.classList.add('hint')
						errorSpan.textContent = letter
						return errorSpan
					}

					return letter
				})
		)

		/*
			Пройти по всем строкам, которые нужно отобразить и напечатать,
			кроме начальной.
		*/
		for (let i = 1; i < showedStrings.length; i++) {
			// Текущая строка из тех, которые нужно отобразить и напечатать.
			const line = document.createElement('div')
			line.classList.add('line')
			div.append(line)

			/*
				Добавить в текущую строку текст, который нужно напечатать.
			*/
			line.append(
				...showedStrings[i]
					.split('')
					.map(letter => {
						// Если текущий символ - пробел:
						if (letter === ' ') {
							// Заменить пробел на отображаемый символ пробела.
							return '␣'
						}

						// Если текущий символ - конец строки:
						if (letter === '\n') {
							/*
								Заменить конец строки на отображаемый символ конца
								параграфа.
							*/
							return '¶'
						}

						// Если ранее ошиблись в наборе символа:
						if (party.errors.includes(letter)) {
							// Вернём этот символ выделенным.
							const errorSpan = document.createElement('span')
							// Выделить этот символ.
							errorSpan.classList.add('hint')
							errorSpan.textContent = letter
							return errorSpan
						}

						return letter
					})
			)
		}

		// Очистить блок со строками, которые нужно отобразить и напечатать.
		textExample.innerHTML = ''
		/*
			Вставить в блок со строками, которые нужно отобразить и напечатать,
			контейнер с этими строками.
		*/
		textExample.append(div)

		// Вставить в поле для ввода символов часть строки, которую уже напечатали.
		input.value = string.slice(0, party.currentPressedIndex)

		// Если ещё не начали набор строки и партия тренировки уже стартовала:
		if (!party.statisticFlag && party.started) {
			// Обновить статистику.
			// Скорость набора, измеряемая в знаках в минуту.
			const charactersPerMinute =
				Math.round(60000 * party.commonCounter / party.timerCounter)
			// Индикатор количества набранных символов в минуту.
			symbolsPerMinute.textContent = charactersPerMinute

			// Скорость печати в "словах в минуту".
			const wordsPerMinute =
				Math.round(charactersPerMinute / AVERAGE_LENGTH_OF_AN_RUSSIAN_WORD)
			// Записать значение в индикатор "Слов в минуту:".
			wordsPerMinuteIndicator.textContent = wordsPerMinute

			// Скорость печати в "реальных словах в минуту".
			const realWordsPerMinute =
				Math.round(60000 * wordsPerLine / party.timerCounter)
			// Записать значение в индикатор "Реальных слов в минуту:".
			realWordsPerMinuteIndicator.textContent = realWordsPerMinute

			// Индикатор количества ошибок.
			errorPercent.textContent = Math.floor(
				(10000 * party.errorCounter) / party.commonCounter
				) / 100 + '%'

			// Обнулить количество напечатанных символов в текущей строке/
			party.commonCounter = 0
			// Обнулить количество ошибок в текущей строке.
			party.errorCounter = 0
		}
	}

}

main()